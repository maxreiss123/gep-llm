# coding=utf-8
"""
.. moduleauthor:: Shuhua Gao

This module :mod:`parser` provides functionality for compiling an individual (a chromosome) in GEP into an executable
lambda function in Python for subsequent fitness evaluation.

.. todo::
    Parse an individual into codes of other languages, such as C++/Java, for deployment in an industrial environment.
"""

import sys


def _apply_rec_linker(linkerlist, linked_, chromos):
    if len(chromos) == 0 or len(linkerlist) == 0:
        return linked_
    if linked_ is None:
        return _apply_rec_linker(linkerlist, linkerlist.pop()(chromos.pop(), chromos.pop()), chromos)
    else:
        return _apply_rec_linker(linkerlist, linkerlist.pop()(linked_, chromos.pop()), chromos)


def _compile_gene(g, pset):
    """
    Compile one gene *g* with the primitive set *pset*.
    :return: a function or an evaluated result
    """
    code = str(g)
    if len(pset.input_names) > 0:  # form a Lambda function
        args = ', '.join(pset.input_names)
        code = 'lambda {}: {}'.format(args, code)
    # evaluate the code
    try:
        return eval(code, pset.globals, {})
    except MemoryError:
        _, _, traceback = sys.exc_info()
        raise MemoryError("The expression tree generated by GEP is too deep. Python cannot evaluate a tree higher "
                          "than 90. You should try to adopt a smaller head length for the genes, for example, by using"
                          "more genes in a chromosome.").with_traceback(traceback)


def compile_(individual, pset):
    """
    Compile the individual into a Python lambda expression.

    :param individual: :class:`Chromosome`, a chromosome
    :param pset: :class:`PrimitiveSet`, a primitive set
    :return: a function if the primitive set *pset* has any inputs (arguments), which can later be called with
        specific parameter values; otherwise, a numerical result obtained from evaluation.
    """
    fs = [_compile_gene(gene, pset) for gene in individual]
    linker = individual.linker
    if linker is None:  # return the gene itself for a monogenic one or tuple of all genes
        if len(fs) == 1:
            return fs[0]
        else:
            return lambda *x: tuple((f(*x) for f in fs))
    if isinstance(linker, list):
        return lambda *x: _apply_rec_linker(linker.copy(), None, [f(*x) for f in fs])
    else:
        return lambda *x: linker(*(f(*x) for f in fs))


def compile_to_function_string(individual, function_map, arity_map, **kwargs):
    """
    Using the compile recursive for the expression
    """
    rek_string = compile_to_recursive(individual, function_map).replace(' ','').split(',')
    stack = []
    for elem in rek_string[::-1]:
        if arity_map.get(elem, 0) == 2:
            op1 = stack.pop()
            op2 = stack.pop()
            stack.append('(' + op1 + elem + op2 + ')')
        elif arity_map.get(elem, 0) == 1:
            op1 = stack.pop()
            stack.append(elem + '(' + op1 + ')')
        elif arity_map.get(elem, 0) == -1:
            op1 = stack.pop()
            stack.append('(' + op1 + ')'+elem)
        else:
            stack.append(elem)
    return stack[-1]


def compile_to_recursive(individual, function_map=None, **kwargs):
    """
    Stringify the expression into a recursive list to evaluate this within a foam application
    """
    recursive_rows = []
    entry = []
    linker_ = [elem.__name__ for elem in individual.linker]
    for elem in individual.kexpressions:
        entry.append(elem.simple_string())
    recursive_rows.append(','.join(linker_) + ',' + ','.join(entry))

    if function_map is not None:
        for index, line in enumerate(recursive_rows):
            for key, value in function_map.items():
                line = line.replace(key, value)
            recursive_rows[index] = line
    return recursive_rows[-1]


def _decode_list_of_kexpressions(list_key_expressions, linker, symbol_map={}, link_index=0):
    if len(list_key_expressions) == 1:
        return list_key_expressions[0].str_repr(symbol_map)
    elif len(list_key_expressions) == 2:
        return linker[link_index % len(linker)].str_repr(symbol_map).format(
            list_key_expressions[0].str_repr(symbol_map),
            list_key_expressions[1].str_repr(symbol_map))
    else:
        next_expression = list_key_expressions.pop(0)
        return linker[link_index % len(linker)].str_repr(symbol_map).format(next_expression.str_repr(symbol_map),
                                                                            _decode_list_of_kexpressions(
                                                                                list_key_expressions,
                                                                                linker, symbol_map,
                                                                                link_index + 1))


def decode_recursive_kexpression(list_key_expressions, linker, symbol_map={}):
    temp_kexpressions = list_key_expressions.copy()
    temp_linker = [linker] if not isinstance(linker, list) else linker
    return _decode_list_of_kexpressions(temp_kexpressions, temp_linker, symbol_map)


__all__ = ['compile_']
